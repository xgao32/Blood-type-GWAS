# Predict status of causal variant 
This R markdown file is a prototype to test code. Actual script for doing prediction of causal variant from associated variants is `00_predict.R`.

```{R,message=False}
# set directory
if (dir.exists("/hpctmp/xgao32/Blood-type-GWAS/biobank/1KG/phase3_grch37/")) {
    # Set the working directory
    setwd("/hpctmp/xgao32/Blood-type-GWAS/biobank/1KG/phase3_grch37/")
    } else {
    setwd("/workspaces/Blood-type-GWAS/biobank/1KG/phase3_grch37/")
    }
```

```{R, message=FALSE}
# clear all variables
rm(list = ls())

set.seed(0) # set random seed
load(".RData")
# Load necessary libraries
library(ggplot2)
# library(vcfR)
#library(genio)
library(dplyr)
library(VariantAnnotation)
library(GenomicRanges)
library(caret)
library(naivebayes)
library(pROC)
library(e1071)
```



# Load VCF
vcfR requires reading the entire VCF file into memory before doing any operation. VariantAnnotation supports position specific reading of VCF files
```{R}
# list of variant positions based on LD results to extract from VCF 
file_path <- "./LD_result/all_variant_chr23_200kb.ld.ld"
data <- read.table(file_path, header = TRUE)

# Extract chromosome number from file name
chr_num <- gsub(".*chr(.*)_200kb.ld.ld", "\\1", file_path)

# Create the DIST column
data <- data %>% mutate(DIST = BP_A - BP_B)

# Filter the data (adjust filter conditions if needed), not explicitly filtering for R2 with any causal variants
filtered_data <- data %>% filter(MAF_A >= 0.01, MAF_B >= 0.01, SNP_A != SNP_B, R2 >= 0.0)
```
Convert VCF object into data frame
```{R}
SNP_B_positions <-unique(filtered_data$BP_B)
SNP_A_positions <-unique(filtered_data$BP_A)
positions <-c(SNP_A_positions,SNP_B_positions)

gr <- GRanges("X", IRanges(start = positions, width = 1), )
chr23_vcf <- readVcf("./original_data_with_id/chr23.dedup.vcf.gz", param = ScanVcfParam(which = gr))
# chr23_vcf_data <- read.vcfR("../original_data_with_id/chr23.dedup.vcf.gz")

genotype_data <- geno(chr23_vcf)$GT
genotype_phased_df <- as.data.frame(genotype_data) # convert to data frame
```

Create matrix of genotype separated by phase of dimension # variants by # chromosomes
```{R}
# Function to split phased genotypes into two columns
split_phased_genotypes <- function(geno_col) {
    # Split the genotypes on "|" and return a matrix with two columns per sample
    do.call(rbind, strsplit(geno_col, split = "\\|"))
}

# Apply the function to each sample (each column) and combine the results
genotype_split_list <- lapply(genotype_phased_df, split_phased_genotypes)

# Combine the result into a single matrix
genotype_split_matrix <- do.call(cbind, genotype_split_list)

# Convert the split genotype matrix to a data frame
genotype_split_df <- as.data.frame(genotype_split_matrix)

# add row name
variant_positions <- start(rowRanges(chr23_vcf))
rownames(genotype_split_df) <- variant_positions

# transpose dataframe 
df_genotype <- as.data.frame(t(genotype_split_df))

# change all entries from character to factor type 
df_genotype[] <- lapply(df_genotype, as.factor)
```

Naive bayes
```{R}
# summary statistics to see frequency of alleles
summary(df_genotype)

# check for class with 0 counts to decide if laplace smoothing is needed
aggregate(df_genotype,by = list(df_genotype$`2666384`),FUN = table)

# partition data
sub <- createDataPartition(y = df_genotype$`2666384`, p = 0.80, list = FALSE)
df_train <- df_genotype[sub,]
df_test <- df_genotype[-sub,]

# train model on all other
nb_mod <- naive_bayes(`2666384` ~ ., df_train, laplace=0)
summary(nb_mod)

# performance on training set
nb_train_perf <- predict(object = nb_mod, # NB model
                    newdata =  subset(df_train, select = -`2666384`), # predictors
                    type = "class")

# 90% accuracy on training set
train_conf <- confusionMatrix(data = nb_train_perf, # predictions
                                reference = df_train$`2666384`, # mask target variable in training set
                                positive = "0",
                                mode = "everything")

# test set
# performance on training set
nb_test_perf <- predict(object = nb_mod, # NB model
                    newdata =  subset(df_test, select = -`2666384`), # predictors
                    type = "class")

test_conf <- confusionMatrix(data = nb_test_perf, # predictions
                                reference = df_test$`2666384`, # mask target variable in training set
                                positive = "0",
                                mode = "everything")

# predict probabilities to make ROC AUC
nb_test_probs <- predict(object = nb_mod, 
                        newdata = subset(df_test, select = -`2666384`), 
                        type = "prob")

# Create ROC curve
roc_test <- roc(response = df_test$`2666384`, 
                predictor = nb_test_probs[, 1], 
                levels = c(0, 1))


# Plot ROC curve
# Extract specificity and sensitivity values
roc_data <- data.frame(
    specificity = roc_test$specificities,
    sensitivity = roc_test$sensitivities
    )


# Plot ROC curve
ggplot(roc_data, aes(x = 1 - specificity, y = sensitivity)) +
    geom_line() +
    geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
    labs(title = paste(" Xg classification ROC Curve (AUC = ", round(roc_test$auc, 3), ")"), 
        x = "1 - Specificity (False Positive Rate)", 
        y = "Sensitivity (True Positive Rate)") +
    theme_classic()



```

```{R}

```



DOES NOT WORK 
```{R}
# Split data into training and testing sets
# target <- as.character(2666384) # avoid coding column names
trainIndex <- createDataPartition(df_genotype$`2666384`, p = 0.8, list = FALSE)
trainData <- df_genotype[trainIndex,]
testData <- df_genotype[-trainIndex,]


# Define train control with K-fold cross-validation
train_control <- trainControl(
    method = "cv",
    number = 5,  # Number of folds
    savePredictions = "final",
    classProbs = TRUE
    )
    
# Assuming df_train is your training data frame
# Check and rename factor levels if necessary
#trainData$`2666384` <- factor(trainData$`2666384, labels = make.names(levels(as.factor(trainData$`2666384`))))

# Define the tuning grid for Naive Bayes
tune_grid <- expand.grid(
    laplace = c(1),            # Laplace smoothing parameter
    usekernel = c(FALSE), # Whether to use a kernel density estimate
    adjust = c(1)        # Adjustment parameter for kernel density estimation
)

# Train Naive Bayes model with caret, 
nb_model <- train(
    `2666384` ~ .,  # Formula
    data = trainData,
    method = "naive_bayes",
    trControl = train_control,
    tuneGrid = tune_grid
    )

# Error: At least one of the class levels is not a valid R variable name; This will cause errors when class probabilities are generated because the variables names will be converted to  X0, X1 . Please use factor levels that can be used as valid R variable names  (see ?make.names for help).


# Make predictions on test data
predictions <- predict(nb_model, newdata = testData, type = "prob")


# Calculate ROC curve and AUC
roc(testData$target, predictions[, 1])  # Assuming class labels are 0 and 1

```



# checking for additional rows in VCF object more than actual number of variants
```{R}
# why more positions loaded from VCF file than number of positions?
# Get the positions of the variants in the VCF object
vcf_positions <- start(rowRanges(chr23_vcf))

# Compare the number of positions
length(positions)  # The number of positions you queried
length(vcf_positions)  # The number of positions in the VCF object

# Check for overlapping positions
overlapping_positions <- intersect(positions, vcf_positions)
length(overlapping_positions)  # Number of positions that overlap with your query


```

# genio

Load PLINK bed/fam/bim file. PLINK bed files do not store phasing information of genotypes.
```{R}
chr23_filtered_vcf_plink <- "./filtered_vcf/chr23.final"
chr23_geno_data <- read_plink(chr23_filtered_vcf_plink)  # object with X, bim, fam 

# matrix of genotypes
chr23_mat = chr23_geno_data$X
chr23_phased_df <- as.data.frame(chr23_mat) # number of variants by 2504, df contains 0/1/2 to represent state of alleles
```